import macros
import strformat, strutils
import hmisc/defensive
import sets
import grammars

# Only `kind` for token is considered while parsing - some additional
# information can be generated by lexer (string value for token,
# start/end position etc.). This information is not used in LL(1)
# parser.

proc computeFirst[TKind](patt: Patt[TKind], other: NTermSets[TKind]): FirstSet[TKind] =
  ## Generate FIRST set for `patt`
  case patt.kind:
    of pkTerm:
      result.incl patt.tok
    of pkConcat:
      result.incl computeFirst(patt.patts[0], other)
    of pkAlternative:
      for p in patt.patts:
        result.incl computeFirst(p, other)
    of pkOptional, pkZeroOrMore, pkOneOrMore:
      result.incl computeFirst(patt.opt, other)
    of pkNterm:
      result.incl other[patt.sym]

proc computePatt[TKind](patt: Patt[TKind], sets: NTermSets[TKind]): CompPatt[TKind] =
  ## Generate FIRST set for pattern `patt`
  result.patt = patt
  result.first = computeFirst(patt, sets)

proc computeGrammar[TKind](g: Grammar[TKind]): CompGrammar[TKind] =
  var sets: NTermSets[TKind]
  for rule in g.rules:
    let compPatt = computePatt(rule.patts, sets)
    sets[rule.nterm] = compPatt.first
    result.rules.add CompRule(nterm: rule.nterm, patts: compPatt)

proc newSetLiteral[T](s: set[T]): NimNode =
  ## Create new set literal
  discard

type
  CodeGenConf = object
    laIdent: string
    lexIdent: string

proc makeParseBlock[TKind](patt: CompPatt[TKind], conf: CodeGenConf): NimNode

proc makeAltBlock[TKind](alt: CompPatt[TKind], conf: CodeGenConf): NimNode =
  ## Create code block for parsing alternative pattern
  assert alt.kind == pkAlternative
  result = nnkCaseStmt.newTree(ident conf.laIdent)
  for patt in alt:
    result.add nnkOfBranch(
      newSetLiteral(patt.first),
      makeParseBlock(patt)
    )

  let elseBody = quote do:
    raise CodeError(msg: "Unexpected token")

  result.add nnkElse(elsebody)

proc makeParserName(sym: NTermSym): string =
  ## Converter nonterminal name into parsing proc name
  "parse" & sym.capitalizeAscii()

proc makeTermBlock[TKind](nterm: CompPatt[TKind], conf: CodeGenConf): NimNode =
  assert nterm.kind == pkNTerm
  let ntermIdent = ident(makeParserName(nterm.sym))
  let lexerIdent = ident(conf.lexIdent)
  quote do:
    `ntermIdent`(`lexerIdent`)

proc makeNTermBlock[TKind](nterm: CompPatt[TKind], conf: CodeGenConf): NimNode =
  discard

proc makeConcatBlock[TKind](nterm: CompPatt[TKind], conf: CodeGenConf): NimNode =
  discard

proc makeNtoMTimesBlock[TKind](
  nterm: CompPatt[TKind], conf: CodeGenConf,
  mintimes, maxtimes: int): NimNode =
  assert nterm.kind in {pkZeroOrMore, pkOneOrMore, pkOptional}

proc makeParseBlock[TKind](patt: CompPatt[TKind], conf: CodeGenConf): NimNode =
  ## Generate code block to parse pattern `patt`.
  case patt.kind:
    of pkTerm:
      makeTermBlock(patt, conf)
    of pkOptional:
      makeNtoMTimesBlock(patt, conf, 0, 1)
    of pkNterm:
      makeNTermBlock(patt, conf)
    of pkAlternative:
      makeAltBlock(patt, conf)
    of pkConcat:
      makeConcatBlock(patt, conf)
    of pkZeroOrMore:
      makeNtoMTimesBlock(patt, conf, 0, -1)
    of pkOneOrMore:
      makeNtoMTimesBlock(patt, conf, 1, -1)
