** FSmonitor

*** Internal working

This thing works like this: each fsmonitor holds async file descriptor
to _inotify_ event queue.

~readEvents~ creates callback closure (and buffer to write inotify
events to) and ads this to ~addRead~ for file descriptor that is being
held by ~FSMonitor~. When event occurs on the file (i.e. inotify adds
event to queue) the callback ~callbackClosure~ is called (which in
turn calls ~callbackClosureImpl~).

# TODO ???

readEvents creates closure and adds it as a callback for fdmonitor fd.
closure will be called when event occurs, but doesn't this mean that
we might get invalidated buffer?

Oh, this would've happen if the buffer was allocated on stack. But
because it is allocated on heap and has multiple users (each closure
instance has ~var string~ that uses buffer)

*** ~callbackClosureImpl~

~ssize_t read(int fd, void *buf, size_t count);~ : posix.read()
attempts to read up to count bytes from file descriptor fd into the
buffer starting at buf.

To determine what events have occurred, an application read(2)s from
the inotify file descriptor. If no events have so far occurred, then,
assuming a blocking file descriptor, read(2) will block until at least
one event occurs http://man7.org/linux/man-pages/man7/inotify.7.html

*** ~FSMonitor::watch~

Call read events. In return we get ~Future[seq[MonitorEvent]]~. Add
callback for future finish. Callback calls watch function again so we
don't need to use async/await to get events - callbacks for monitor
events will be called indefinitely @[Will we get stack overflow from
too deep recursion?].

*** Usage

Two options: create monitor and add callback or do ~while true: let
events = await monitor.read()~. Second option allows (Is this
correct?) to process files in batches.

** Argparse

*** Use cases.

This module has two intended use cases. *First one*: you put
~parseArgs~ directly in the main file (maybe after ~when
isMainModule~) and use ~argParsed~, ~optParsed~ etc. immediately.
*Second one*: you write proc that does all of the parsing, builds
single object with all configuration options and returns it to the
caller.

All checks for correctness of the input string were already made, so
it is realtively safe to assume that if specified type of the argument
as ~seq[string]~ you can then parse it directly using ~toStrSeq~. To
check if key is present you can use ~kp~ (abbreviation from ="key
present?"=) template. It accepts string as first and only argument so
you can do things like: ~"silent".kp~ to check if key is present. To
get value of particular key you can use ~k~ template (abbreviation
from ="key"=).

First use case looks like this:

#+HEADERS: :noeval
#+BEGIN_SRC nim
when isMainModule:
  parseArgs:
    opt:
      name: "test"
      opt: ["--test", "+takes_value"]
      help: "soem help"

  if "test".kp:
    echo "test".k.toStr()
#+END_SRC

Second use case looks like this:


#+HEADERS: :noeval
#+BEGIN_SRC nim
  type
    OperationMode = enum
      doTest
      doAction

    CmdLineParsed = object
      optParsed = Table[string, CmdArg]
      argParsed = seq[string]
      case kind: OperationMode:
        of doTest:
          target: string
        of doAction:
          nukeEverything: bool = true


  proc parseCMDLine(): CmdLineParsed =
    parseArgs:
      opt:
        name: "type"
        opt: ["--type", "+takes_value", "+required"]
        takes: ["test", "action"]
        help: "Choose operation mode"

    let kind =
      case "type".k.toStr():
        of "test": doTest
        of "action": doAction

    result = CmdLineParsed(kind: kind)

when isMainModule:
  let opts = parseCMDLine()
#+END_SRC

Which is of course more verbose but better suited for complicated tools



** Input


@idea[nim, argparse]: instead of using string and table to check for
subcommands I can generate enum of all possible options. I can also
generate proc for doing parsing that returns optParsed, argParsed ETC.
instead of injecting them into global scope.;

Having enum with all arguments also give advantage of being able to
iterate through them.

I can generate single *huge* case object that encodes all possible
commands, subcommands, options and arguments as well as help, types,
default values etc.
