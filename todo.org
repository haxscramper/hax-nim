* general

** workflow description

+ Two types of workflow: on a single script or on the multi-file
  project

Setup script to genrate all project files: set execution permissions
on watch scripts, generate main project files, setup build commands
etc.

*** Single-file projects

Single script called ="start-coding.sh"= or something along those
lines. It accepts single argument - name of the file you want to start
working on.

+ If the file does not exist it will be created
+ Along with project files ~test.sh~ script will be created and
  launched.

This script is launched by ~start-coding.sh~ and re-executed when
necessary. It contains several auto-generated functions, one for each
script/binary you want to test in this directory together with build
options for each of them.

**** Workflow example:

I want to write perl script called ~temp.pl~ and then launch it with
some command line arguments for testing. My actions:

1. Run ~start-coding.sh temp.pl~
2. Open auto-generated ~test.sh~ and go to the body of the function
   called ="run_temp_pl"= and put my testing code here.
3. Open file ~temp.pl~ in text editor of choice and start writing
   code.
4. When I save ~temp.pl~ i should see new test being ran immediately
   by ~test.sh~

**** Questions

+ What if I don't want to pollute each of the directory with test
  scripts
  + Fsm-build can be used as standalone tool without any additional
    shell scripts. In this case it has more limited capabilities (it
    only supports building using predefined set of build commands (can
    be configured using toml file) and running tested application with
    certain parameters (can be configured)). It does _not_ support
    running test for multiple files at the same time.
+ What if I want to watch for more files than already provided?
  + You can create ~test_conf.toml~ and put list of the files you want
    to monitor. Additional configuration file will not be generated
    automatically but if you add it it will be automatically detected
    and files from it would be added to watch list. Any subsequent
    changes to configuration file will also be accounted for.
+ How to exclute files from watch list?
  + Put them into ="excluded"= section in the ~test_conf.toml~
+ How to start working on new script in the same directory while not
  losing all of the changes in test script?
  + Run ~start-coding.sh~ again with different arguments. All changes
    will be added to the test script automatically whithout destroying
    your previous work.
+ How to deal with scripts that might take forever to complete? What
  happens if I accidentally write script that has endless loop? Or I'm
  intentionally writing script with async loop?
  + Automatically generated testing function includes call to
    ~killall~ for your script. For running script is forked so that it
    does not block execution of the test script.
+ Do I need to write commands for building everything each time?
  + No. fsm-builder allows you to write predefined configuration file
    with common build commands and then use them to build/run things.

*** For multi-file projects

* CLI tools

** Colecho

+ [ ] Remove hardcoded terminal width regulation. If launched in tty
  with no =X= running fit as many characters per line as possible.
+ [ ] Macro for printing messages (similar to ~LOG~ in DebugMacro)
  that does not require adding commas (instead of ~LOG "sdfsd",
  "SDF"~ use ~LOG "sdf" DSF~)
+ [ ] Printing large terminal-wide separators with multiple lines
+ [ ] Generate headers like this (even though it is probably better to
  use in =fmtecho=)
#+HEADERS: :noeval
#+BEGIN_SRC txt
vvvvvvvvvvvvvvvvvvv
>>>> Some text <<<<
>>>> goes here <<<<
^^^^^^^^^^^^^^^^^^^
#+END_SRC
+ [ ] Separators for beginning/end of the section. Generate
  terminal-wide separtors
+ [ ] Another message style or replacement of current vebose more.
  Current version is no really good to look at because it hash a lot
  of visual noise. Better have something with words but no braces and
  three-letter words. ~Err, Wrn, Log, Inf~ would be good enough.
  Without numbers

*** TODO Colecho [2/10]
**** DONE #idea Implement support for "         ]" in colecho
     CLOSED: [**** 2019-08-06 Tue 17:25]
     Add option for omitting some parts of the prefix and only
     printing last one: for example, for ~[ ERROR 3 ]:~ I would leave
     only last two characters (~]:~) and coloring. When printing long
     outputs (for example for ~git log --oneline --decorate --graph
     -n10 --color=always | xargs -i colecho -v {}~) it might be
     overkill to add ~[ LOG ...~ to each invocation.
**** DONE #fix Uniform coloring does not work in colecho
     CLOSED: [**** 2019-08-06 Tue 17:39]
**** TODO #idea Read string from stdin [%]
     * [ ] Read from stdin
     * [ ] Automatically wrap long text and buffer output
**** TODO prettier indentation for vebose mode
     Instead of shifting output as a whole it would be much better to
     separate it into two parts: one that stays still and one that will
     be indented. For verbose log it might look better if I shift this
     like this: ~[ LOG   0 ] -> [ LOG   0     ]~. Of course this requires
     some tesing.
**** TODO #fix multi-line printing loses color.
     When ooutputting long string that gets wrapper around
     automatically indentation prefix is added (for verbose mode it is
     " |" with required number of spaces). The "|" part is not not
     colored if used with info/warn/error modes.
**** TODO #fix Broken automatic string wrapping for non-zero indentation
**** TODO #idea --color=* support
**** TODO #idea Write to files
     + [ ] Add support for outputting everything into file
     + [ ] Duplicate logging records (~--Log~ mode) into
       ~~/.config/hax-local/log/~ by default (allow changing logging
       directory)

**** TODO #idea #emacs##highlighting highlighting for colecho log files
**** TODO #idea save indentation level for "parser mode"
     + Save indentation level
     + Read system variable for setting indentation level, modify it
       on each invocation
     + Preserve indentation when recursively calling makefiles?
     + [[https://www.google.com.ar/search?q=make%20export%20system%20variables][google]]
**** TODO other [/]
     + [ ] Use simple equation to calculcate right trim for each
       invocation - this can be used to generate interesting patterns
       in messages
     + [ ] Replace part of the prefix with custom string of certain
       length that will keep styling. Ex: if I use gtest style and
       want to replace right part of the prefix with word ="parsing
       :"= I should get ~[## parsing:~ as result. This is useful for
       outputting colorful error messages that are not visually
       cluttered and have keywords highlighted. Option name:
       ~--rplace~, accepts string *or* tuple =(string,int)= when
       second option indicates number of characters in prefix. This
       might be used when printing long prefixes (such as
       "Downloading" which is pretty common, but it is 11 characters
       long and longer than even gtest prefix) that will eat up all of
       the original prefix (and it might be not enough).
     + [ ] ~Either~ or ~Variant~ type is necessary to parse values
       that might have optional signatures. Parsing function should
       return ~Option[Variant[A,B,C]]~ and end checking should switch
       state on the type of variant (@idea[nim,patter-machin,
       metaprogramming]: implement/find library for matching arbitrary
       variant types;)
     + [ ] Parsing of variant-typed objects should give meaningful
       error messages: instead of saying ="Cannot parse to
       'Variant[A,B,C]'"= It might be better to say ="Unable to parse
       to any of the 'A', 'B' or 'C'"

** Other

*** TODO Generate help messages from toml files. [0/4]
    + [ ] Read toml from file
    + [ ] Use rst/org-mode formatting
    + [ ] #!! Piple toml to help generator --- the most useful thing
*** TODO Validate CLI options for scripts
    Send all options and required options to colecho to check whether
    or not they are valid.
    + It is possible to create associative arrays in bash --- checking
      for option correctness is relatively complicated in bash, but
      when all checks are done it is only a matter of checking for keys
      in dictionary
#+HEADERS: :noeval
#+BEGIN_SRC bash
  declare -A arr=();
  cat << EOF | argcheck -- "$@" | while read -r a b; do arr["$a"]="$b"; done
  [[arg]]
  name = "input-file"
  type = "file:rw:er"
  help = "Input file"
  opt = ["+takes_value", "required"]
  EOF

  # If any arguments are wrong it meaningful error will be provided with
  # full description of everything of what is expected + auto-generated
  # help message without need to do any ugly ~if [[ -e "$1" ]]~ on
  # script. Arguments will be placed (hopefully) in associative array

  if [[ "${arr[input-file]}" == "hello.txt" ]]; then
      # We are sure that this file exits, it has rw privileges (at
      # least).
      colecho -w "Required file is hello.txt, need special actions"
      head "hello.txt" | cut -d' ' -f3 | sed 's/%/()/g'
  fi

#+END_SRC

    @[is this correct org-mode syntax? I already ended paragraph but I
    have the same indentation. This counts as new section or as old
    one?] Is it possible to store arrays in values in associative
    arrays?

    Another interesting thing that comes out or ~argcheck~ is
    automatic handling of =--help=, =--version= etc. -- I can simply
    look for passed options and do some more actions based on them.
*** TODO Runtime parse checking
    Right now checking for each type is performed based on static type
    passed to option definitions (@todo: need to change from `arg` to
    `opt`;), but for parsing this for any toml file more complicated
    checkings needs to be done
    + [ ] Parse nim type definitions
    + [ ] Parse type definitions used in codegen


*** TODO moustache package fix [0/2]
    + [ ] Remove case transition from objects
    + [ ] Add support for using toml files

** FSM build

+ [ ] Display process animation while building files for java
  (#interesting)
+ [ ] Add support for running custom user-defined command (dynamically
  selected) after each event. Support selecting command from socket
  and during runtime.
  + [ ] Save selected commands to temporary file in local directory
    and use it on subsequent starts.
+ [ ] Solve M-to-N problem for selecting build, run and preview
  commands: maybe separate them into two different categories (=build=
  and =run=)
+ [ ] Add support for preview command. User should be able to choose
  from running preview each time build is succeded or once, after
  first build.
+ [ ] Provide template variables for file without extension (ex: when
  i compile =file.tex= it's filename is =file= and last extension is
  =tex=). This is useful for running preview commands and different
  log parsers.
+ [ ] Add support for running commands on build fail (useful for
  hooking things on parsing latex build logs)
+ [ ] List all extensions and build commands for each extension
+ [ ] Highlight build command name and actual build command
+ [ ] Add check for installed software (list commands and then check
  whether or not each command exists)
+ [ ] Add support for generating files using scripts;
+ [ ] If no templates are present ask to create empty file instead of
  crashing.
+ [ ] Recursively search C++ files starting from main one to determine
  list of files to watch.
+ [ ] Support outoutting file events in a form of json (for use in
  elvish shell)
+ [ ] Rescan directory after each rebuild to check for new files
+ [ ] If file glob is missing search for all files with the same
  extension (except for c++ files - in that case search for ~*.cpp~
  and ~*.hpp~)
+ [ ] Pipe test data into build - read local test/configuration files
  + [ ] Generate test input using bash scripts
+ [ ] Preset for debuggint graphviz files using sxiv image viewer.
#+HEADERS: :noeval
#+BEGIN_SRC bash
echo "Updating"
dot test.dot -Tpng > test.png
cp test.png res.png # To avoid dying on missing file
#+END_SRC
+ [ ] testing script in perl and not in bash
+ [ ] Buffer file changes and generate json output. - write simple
  wrappper CLI tool to watch set of files/directories. This is
  especially useful with elvish shell.
+ [ ] Show which files will be globbed when selecting build options.
  Add support for multiple globbing strategies for a single build
  command.
+ [ ] If missing build and run command do not perform build at all
  instead of substituting ~./{{input_file}}~.
+ [ ] #!! Add support for postponing launch of the application until
  certain event (signal on socket). This is very useful when writing
  simple gui applications and you want to compile often but run the
  application only when some important change occurs.
+ [ ] #! (addition to previous): add support for launching application
  via multiple different commands --- this is also useful for testing
  of some application when you want to run gui only sometimes but some
  other things require more frequent runtime testing. One of the
  examples: you write GUI app and have some sort of file loading at
  the start (reading configuration, opening default project etc) and
  want to test this. You can comment and uncomment code for launching
  app gui each time you want to test it, but it is much easier to bind
  shortcut for that kind of actions. On shortcut you send signal to
  currently running fsm-build and next time your application is built
  it will be launched with some command-line argument.
+ [ ] #interesting Add support for running perl scripts as command to
  generate bash commands (finding files, substituting strings etc).
+ [ ] #need-to-test Support for makefiles in some way?
+ [ ] Add ~--quiet -q~ option for supressing any messages except
  separators and ~--quiet2 --q2~ for supressing absolutely all
  messages that are not genrated by build or run.
+ [ ] Add ~--indent~ to add indentation for output of the build and
  run.
+ [ ] User-defined variables for script templates. Can be added in top
  section for the configuration script or parsed from output of the
  scripts located at ~~/.config/hax-config/config/vars.sh~ or
  ~~/.config/hax-local/config/vars.sh~. @[Pass some arguments to the
  scripts to determine which output should be generated?]
+ [ ] Build command for standalone tikz images that are included in
  other files: generate temporary file with the correct wrapping, add
  original file body to it, compile, convert to pdf and show as image
  in terminal using kitty. Might also use regular script templates and
  do some =sed= replacements in the middle to avoid having to do ~echo
  << EOF~ @[script template with comment that will be replaced on sed
  run]
+ [ ] Add build script to the list of watched files

** Script templating

+ [ ] Inotify watch script template with support for selecting files
  to watch for (they will be added into ~if [[ "$file" == "file1" ] ]~
  or extenstion matchers)

** Fasnotes

*** Inline source code blocks with highlighting

+ ~~nim||~ - first argument is the name of the language to use in
  syntax highlight

*** Import source code blocks using tags and not code ranges

Right now I can do ~#+include: "<file-localtion>"

*** Annotated templates for source code

I have some piece of code that I want to annotate, but for some reason
I don't want to put comments directly into the code. I can just add
comments like this (assuming =C= code): ~/* <1> */~ and then add
description list for each of them.

#+HEADERS: :noeval
#+BEGIN_SRC c
int main(
  int argc, // <1>
  const char** argv // <2>
) {

}
#+END_SRC

#+HEADERS: :noeval
#+BEGIN_SRC text
- <1>{argument count} :: Number of items in argv
- <2>{arguments} :: Array of pointers to argument strings
#+END_SRC

placeholders in code will be replaced by text in curly braces.

This is useful when writing lots of comments for small piece of code
and you dont want to have comment to code ratio of 3/1.

#+HEADERS: :noeval
#+BEGIN_SRC c++
template <class T>
T& /*1*/ scastp(void* arg) {
    return * /*2*/ static_cast<T*>(arg);
}

namespace internal {
struct C {
    void member_method();
};


const size_t ptr_size = sizeof(/*3*/&C::member_method);
using ptr_arr         = char[/*4*/sizeof(&C::member_method)];
#+END_SRC

or can even create simpler notation (~/*n*/~)

#+CODE_COMMENT


- <1> :: return reference because objects is already allocated
         somewhere and we only need to change it's type
- <2> :: Dereference pointer generated by static cast
- <3> :: Size of pointer to class method
- <4> :: ~sizeof~ is compile-time constant so we can create array of
         chars (bytes) that can hold pointer.

We need to search for next description list until the end so no
closing opening is necessary?

* TODO Nim todo list [0/9]
** TODO #easy mapIt1/mapIt2 - same idea but inject ~it1~ and ~it2~
   Sometimes it is necessary to have two nested iterations and get
   access to both variables
** TODO [#B] Implicitly import all modules required by template/macro
** TODO macro for brace initialized list
** TODO macro for defining structures with default arguments
   (I need to define new* proc if I understand everything correctly)
** TODO List comprehension
** TODO Pipe-like function calls
** TODO Command-line argument parser generator built on top of `parseopts`
** TODO Utility functions for reading Toml files
** TODO Colecho code generator and built-in function
** TODO CL-like `loop` macro supportinhg most commonly used operators (and my own additions)
   + minimizing
   + finally
   + collect (into)
   + between
** TODO [#C] shell-like pipes with support for running shell commands directly

Example of useage:
#+BEGIN_SRC nim
# V Abbriveation from "shell pipe"
shp![$(ls) # Run shell command
     |> duplicate # Repeat each entry
     |> dup!
        ( # Put each item that passe through the pipe into two commands
          >(... some command ...)
          >(... another command ...))
     |> merge! # Compine output of the two commands
     |> filter![x => x % 2 == 0]] # Filter only entries that match predicate
#+END_SRC

After some modifications it looks like this

#+HEADERS: :noeval
#+BEGIN_SRC nim
  shp:
    sh! "ls -al" # Run shell command
    |> duplicate! # Repeat each entry
    |> multiplex!
      ( # Put each item that passe through the pipe into two commands
        >(it * 2), # Similar to ~mapIt~ template variable ~it~ is
                   # injected
        >(it)
      )
    |> merge! # Combine output of the two commands.
    |> filter![x => x % 2 == 0] # Filter only entries that match
                                # predicate
#+END_SRC

this does not cause compilation errors and is parsed into somewhat
acceptable tree. Main issue is parsing deeply nested infix notations:

#+HEADERS: :noeval
#+BEGIN_SRC text
  Infix
    Ident "!"
    Infix
      Ident "!"
      Prefix
        Ident "|>"
        Ident "merge"
      Prefix
        Ident "|>"
        Ident "filter"
    Bracket
      Infix
        Ident "=>"
        Ident "x"
        Infix
          Ident "=="
          Infix
            Ident "%"
            Ident "x"
            IntLit 2
          IntLit 0
#+END_SRC

** TODO Simplify passing down common options

In some cases I don't want to have global variables for configuring
state and want to pass options explicitly, even if it means that I
have to add the same argument on each function call. This is very
simple task, but it creates somewhat silly looking code like
~myProc(opt = opt, opt1 = opt1)~ that looks like complete bolierplate.
It might be easier to write some kind of macro to automate writing
these ~a = a~ things and show that I'm simply passing options down for
other proc.

** Codegen

+ [ ] #wip Templating engine for common code constructs (currently in
  the workings). In some cases there are very common code constructs
  (repeated if-else statements, struct/class definitions for storing
  data, xml parser code, method calls, vector/array/iterator
  algorithms) that are *very* similar in all C-family languages. It
  might be possible to automate process of writing these things using
  templating engine for code and some scripting language built-in into
  templates.

** Create-script

+ [ ] #!!! Make more descriptive names for script templates, add
  unames and error checking like in ~fsm-build~
+ [ ] #!! Move script templates and build commands into =hax-nim= repo

* Ideas
** CL-like loop macro [0/8]

+ [ ] Minimize
+ [ ] Maximize
+ [ ] for x in ...
+ [ ] finally
+ [ ] do
+ [ ] initially (or init for short)
+ [ ] better support for working with optional types
+ [ ] generate iterator instead of a sequence (so that `loop` can also
  be used as body for closure/inline iterators)

** Other

+ Is it possible (via some crazy hack) to replace built-in compiler
  functions with something else? If i want to have prettier
  stacktracing function. Something along the lines of hot-patching of
  vtables in C++
+ Is it possible to /just/ print stack trace? Without any errors. Just
  get list of current frames/names of called functions.
+ Add support for auto-selecing of the script templates in all
  occasions where this is needed (in functions and in CLI interfaces)
+ Parse string and expand any environmental variables found in it.
  I.e. convert ~"$HOME/test/".exp()~ to correct directory path. Also
  might expand tilde.
+ Create script to recompile all binaries and make symbolic links for
  them
+ Integrate nim's standart logging library into colecho
+ Custom wordwrap
  + Hardwrap text on pipes. When using build command with multiple
    pipes separate text on ~|~ and *then* on newlines
  + Join build commands in single pipe - when specifying build command
    replace each ~\\n~ with nothing as if it was properly escaped
    newline
+ [ ] [#A] Pretty-printing for lists
+ ~rx~ macro for building regular expressions using emacs-lisp-like
  syntax (it would be best to just statically generate string of
  regex)
+ [ ] Simple command-line utility for performing common tasks:
  substituting environment variables and home directory (tilda),
  running templating with some variables (~cat in.file | tool
  --templ-subst:"hostname=${hostname}"~), removing script-style
  comments from files and streams (~cat file.in | tool
  --remove-comments~). This should be a more verbose and fail-safe
  version of common awk/sed patterns. Instead of doing some
  regex-based replacements and running everything throught multiple
  layers of pipes I would rather prefer to do ~cat file.in | tool
  --remove-comments --templ-subst:"filename=file.in"
  --templ-subst:"level=debug" --envsubst --tilda-subst~ which is
  cleanly more verbose but much more human-readable and easier to
  understand compared to ~cat file.in | sed -e '/^#[^!].*/d' -e
  's/\(.*[^!]\)#.*[^}]/\1/' | sed 's/{{filename}}/file.in' | sed
  's/{{level}}/debug/ | envsubst | sed "s/~/$HOME"~
+ [ ] Collection of java misc methods that will be =included= using
  ~m4~ before running main ~java.pl~ and then separated into different
  classes. Need to keep track of include dependencies. #todo: rewrite
  java build script from perl to nim and user proper parser.
+ [ ] Rewrite =camomilla= in nim and use more colorful error
  messaging.
+ [ ] Multiline properties support for org-mode parser
+ [ ] Generate graphviz diagram from source code of peg grammars to
  identiy possible recursive behaviours and visualize grammar as graph
  (which might be very useful for debugging). Another #possibe_idea is
  to step-by-step animation of how parsing is performed. The main
  issue is stability of the graph image, maybe it could be handled if
  we use something other than graphviz for image layout.

* TODO WIP

** TODO support for ignoring certain function names for extract-method
+ [ ] initUI (auto-generated by netbeans)
** TODO [#A] if_let
